{
  "version": 3,
  "sources": ["../node_modules/book-of-spells/src/helpers.mjs", "../node_modules/book-of-spells/src/dom.mjs", "../slideswap.js", "../build/iife.js"],
  "sourcesContent": ["/**\n * Shallow merges two objects together. Used to pass simple options to functions.\n * \n * @param {object} target The target object to merge into\n * @param {object} source The source object to merge from\n * @returns object The merged object, in this case the target object with the source object's properties merged into it\n * @example\n * const target = { foo: 'bar' }\n * const source = { bar: 'baz' }\n * shallowMerge(target, source) // { foo: 'bar', bar: 'baz' }\n */\nexport function shallowMerge(target, source) {\n  for (const key in source) {\n    target[key] = source[key]\n  }\n\n  return target\n}\n\n/**\n * Deep merge function that's mindful of arrays and objects\n * \n * @param {object} target The target object to merge into\n * @param {object} source The source object to merge from\n * @returns object The merged object, in this case the target object with the source object's properties merged into it\n * @example\n * const target = { foo: 'bar' }\n * const source = { bar: 'baz' }\n * deepMerge(target, source) // { foo: 'bar', bar: 'baz' }\n */\nexport function deepMerge(target, source) {\n  if (isObject(source) && isObject(target)) {\n    for (const key in source) {\n      target[key] = deepMerge(target[key], source[key])\n    }\n  } else if (isArray(source) && isArray(target)) {\n    for (let i = 0; i < source.length; i++) {\n      target[i] = deepMerge(target[i], source[i])\n    }\n  } else {\n    target = source\n  }\n  return target\n}\n\n/**\n * Deep clone function that's mindful of nested arrays and objects\n * \n * @param {object} o The object to clone\n * @returns object The cloned object\n * @example\n * const obj = { foo: 'bar' }\n * const clone = clone(obj)\n * clone.foo = 'baz'\n * console.log(obj.foo) // 'bar'\n * console.log(clone.foo) // 'baz'\n * console.log(obj === clone) // false\n * console.log(JSON.stringify(obj) === JSON.stringify(clone)) // true\n * @todo Check if faster than assign. This function is pretty old...\n */ \nexport function clone(o) {\n  let res = null\n  if (isArray(o)) {\n    res = []\n    for (const i in o) {\n      res[i] = clone(o[i])\n    }\n  } else if (isObject(o)) {\n    res = {}\n    for (const i in o) {\n      res[i] = clone(o[i])\n    }\n  } else {\n    res = o\n  }\n  return res\n}\n\n/**\n * Check if an object is empty\n * \n * @param {object} o The object to check\n * @returns boolean True if the object is empty, false otherwise\n * @example\n * isEmptyObject({}) // => true\n * isEmptyObject({ foo: 'bar' }) // => false\n */\nexport function isEmptyObject(o) {\n  for (const i in o) {\n    return false\n  }\n  return true\n}\n\n/**\n * Check if an array is empty, substitute for Array.length === 0\n * \n * @param {array} o The array to check\n * @returns boolean True if the array is empty, false otherwise\n * @example\n * isEmptyArray([]) // => true\n * isEmptyArray([1, 2, 3]) // => false\n */\nexport function isEmptyArray(o) {\n  return o.length === 0\n}\n\n/**\n * Check if a variable is empty\n * \n * @param {any} o The variable to check\n * @returns boolean True if the variable is empty, false otherwise\n * @example\n * isEmpty({}) // => true\n * isEmpty([]) // => true\n * isEmpty('') // => true\n * isEmpty(null) // => false\n * isEmpty(undefined) // => false\n * isEmpty(0) // => false\n */\nexport function isEmpty(o) {\n  if (isObject(o)) {\n    return isEmptyObject(o)\n  } else if (isArray(o)) {\n    return isEmptyArray(o)\n  } else if (isString(o)) {\n    return o === ''\n  }\n  return false\n}\n\n/**\n * Try to convert a string to a boolean\n * \n * @param {string} str The string to convert\n * @returns boolean The converted boolean or undefined if conversion failed\n * @example\n * stringToBoolean('true') // => true\n * stringToBoolean('false') // => false\n * stringToBoolean('foo') // => null\n */\nexport function stringToBoolean(str) {\n  if (/^\\s*(true|false)\\s*$/i.test(str)) return str === 'true'\n}\n\n/**\n * Try to convert a string to a number\n * \n * @param {string} str The string to convert\n * @returns number The converted number or undefined if conversion failed\n * @example\n * stringToNumber('1') // => 1\n * stringToNumber('1.5') // => 1.5\n * stringToNumber('foo') // => null\n * stringToNumber('1foo') // => null\n */\nexport function stringToNumber(str) {\n  if (/^\\s*\\d+\\s*$/.test(str)) return parseInt(str)\n  if (/^\\s*[\\d.]+\\s*$/.test(str)) return parseFloat(str)\n}\n\n/**\n * Try to convert a string to an array\n * \n * @param {string} str The string to convert\n * @returns array The converted array or undefined if conversion failed\n * @example\n * stringToArray('[1, 2, 3]') // => [1, 2, 3]\n * stringToArray('foo') // => null\n * stringToArray('1') // => null\n * stringToArray('{\"foo\": \"bar\"}') // => null\n */\nexport function stringToArray(str) {\n  if (!/^\\s*\\[.*\\]\\s*$/.test(str)) return\n  try {\n    return JSON.parse(str)\n  } catch (e) {}\n}\n\n/**\n * Try to convert a string to an object\n * \n * @param {string} str The string to convert\n * @returns object The converted object or undefined if conversion failed\n * @example\n * stringToObject('{ \"foo\": \"bar\" }') // => { foo: 'bar' }\n * stringToObject('foo') // => null\n * stringToObject('1') // => null\n * stringToObject('[1, 2, 3]') // => null\n */\nexport function stringToObject(str) {\n  if (!/^\\s*\\{.*\\}\\s*$/.test(str)) return\n  try {\n    return JSON.parse(str)\n  } catch (e) {}\n}\n\n/**\n * Try to convert a string to a regex\n * \n * @param {string} str The string to convert\n * @returns regex The converted regex or undefined if conversion failed\n * @example\n * stringToRegex('/foo/i') // => /foo/i\n * stringToRegex('foo') // => null\n * stringToRegex('1') // => null\n */\nexport function stringToRegex(str) {\n  if (!/^\\s*\\/.*\\/g?i?\\s*$/.test(str)) return\n  try {\n    return new RegExp(str)\n  } catch (e) {}\n}\n\n/**\n * Try to convert a string to a primitive\n * \n * @param {string} str The string to convert\n * @returns {null|boolean|int|float|string} The converted primitive or input string if conversion failed\n * @example\n * stringToPrimitive('null') // => null\n * stringToPrimitive('true') // => true\n * stringToPrimitive('false') // => false\n * stringToPrimitive('1') // => 1\n * stringToPrimitive('1.5') // => 1.5\n * stringToPrimitive('foo') // => 'foo'\n * stringToPrimitive('1foo') // => '1foo'\n */\nexport function stringToPrimitive(str) {\n  if (/^\\s*null\\s*$/.test(str)) return null\n  const bool = stringToBoolean(str)\n  if (bool !== undefined) return bool\n  return stringToNumber(str) || str\n}\n\n/**\n * Try to convert a string to a data type\n * \n * @param {string} str The string to convert\n * @returns any The converted data type or input string if conversion failed\n * @example\n * stringToData('null') // => null\n * stringToData('true') // => true\n * stringToData('false') // => false\n * stringToData('1') // => 1\n * stringToData('1.5') // => 1.5\n * stringToData('foo') // => 'foo'\n * stringToData('1foo') // => '1foo'\n * stringToData('[1, 2, 3]') // => [1, 2, 3]\n * stringToData('{ \"foo\": \"bar\" }') // => { foo: 'bar' }\n * stringToData('/foo/i') // => /foo/i\n */\nexport function stringToType(str) {\n  if (/^\\s*null\\s*$/.test(str)) return null\n  const bool = stringToBoolean(str)\n  if (bool !== undefined) return bool\n  return stringToNumber(str) || stringToArray(str) || stringToObject(str) || stringToRegex(str) || str\n}\n\n/**\n * If provided variable is an object\n * \n * @param {any} o \n * @returns boolean\n * @example\n * isObject({}) // => true\n * isObject([]) // => false\n * isObject(null) // => false\n */\nexport function isObject(o) {\n  return typeof o === 'object' && !Array.isArray(o) && o !== null\n}\n\n/**\n * If provided variable is an array. Just a wrapper for Array.isArray\n * \n * @param {any} o\n * @returns boolean\n * @example\n * isArray([]) // => true\n * isArray({}) // => false\n */\nexport function isArray(o) {\n  return Array.isArray(o)\n}\n\n/**\n * If provided variable is a string. Just a wrapper for typeof === 'string'\n * \n * @param {any} o\n * @returns boolean\n * @example\n * isString('foo') // => true\n * isString({}) // => false\n */\nexport function isString(o) {\n  return typeof o === 'string'\n}\n\n/**\n * If provided variable is a function, substitute for typeof === 'function'\n * \n * @param {any} o\n * @returns boolean\n * @example\n * isFunction(function() {}) // => true\n * isFunction({}) // => false\n */\nexport function isFunction(o) {\n  return typeof o === 'function'\n}\n\n/**\n * If object property is a function\n * \n * @param {object} obj\n * @param {string} propertyName\n * @returns boolean\n * @example\n * const obj = { foo: 'bar', baz: function() {} }\n * propertyIsFunction(obj, 'foo') // => false\n * propertyIsFunction(obj, 'baz') // => true\n */\nexport function propertyIsFunction(obj, propertyName) {\n  return obj.hasOwnProperty(propertyName) && isFunction(obj[propertyName])\n}\n\n/**\n * If object property is a string\n * \n * @param {object} obj\n * @param {string} propertyName\n * @returns boolean\n * @example\n * const obj = { foo: 'bar', baz: function() {} }\n * propertyIsString(obj, 'foo') // => true\n * propertyIsString(obj, 'baz') // => false\n */\nexport function propertyIsString(obj, propertyName) {\n  return obj.hasOwnProperty(propertyName) && isString(obj[propertyName])\n}\n\n/**\n * Transforms a dash separated string to camelCase\n *\n * @param {string} str\n * @returns boolean\n * @example\n * transformDashToCamelCase('foo-bar') // => 'fooBar'\n * transformDashToCamelCase('foo-bar-baz') // => 'fooBarBaz'\n * transformDashToCamelCase('foo') // => 'foo'\n * transformDashToCamelCase('fooBarBaz-qux') // => 'fooBarBazQux'\n */\nexport function transformDashToCamelCase(str) {\n  return str.replace(/-([a-z])/g, function (g) { return g[1].toUpperCase() });\n}\n\n/**\n * Transforms a camelCase string to dash separated string\n * \n * @param {string} str\n * @returns boolean\n * @example\n * transformCamelCaseToDash('fooBar') // => 'foo-bar'\n * transformCamelCaseToDash('fooBarBaz') // => 'foo-bar-baz'\n * transformCamelCaseToDash('foo') // => 'foo'\n * transformDashToCamelCase('fooBarBaz-qux') // => 'foo-bar-baz-qux'\n */\nexport function transformCamelCaseToDash(str) {\n  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()\n}\n\n/**\n * Maps an array of objects by a property name\n * \n * @param {array} arr\n * @param {string} propertyName\n * @returns object\n * @example\n * const arr = [{ foo: 'bar' }, { foo: 'baz' }]\n * mapByProperty(arr, 'foo') // => { bar: { foo: 'bar' }, baz: { foo: 'baz' } }\n */\nexport function mapByProperty(arr, propertyName) {\n  const res = {}\n  for (let i = 0; i < arr.length; i++) {\n    res[arr[i][propertyName]] = arr[i]\n  }\n  return res\n}\n\n/**\n * Maps an array of objects by a property name to another property name\n * \n * @param {array} arr\n * @param {string} keyPropertyName\n * @param {string} valuePropertyName\n * @returns object\n * @example\n * const arr = [{ foo: 'bar', baz: 'qux' }, { foo: 'quux', baz: 'corge' }]\n * mapPropertyToProperty(arr, 'foo', 'baz') // => { bar: 'qux', quux: 'corge' }\n */\nexport function mapPropertyToProperty(arr, keyPropertyName, valuePropertyName) {\n  const res = {}\n  for (let i = 0; i < arr.length; i++) {\n    res[arr[i][keyPropertyName]] = arr[i][valuePropertyName]\n  }\n  return res\n}\n\n/**\n * Remove accents from a string\n * \n * @param {string} inputString\n * @returns string\n * @example\n * removeAccents('\u00E1\u00E9\u00ED\u00F3\u00FA') // => 'aeiou'\n * removeAccents('\u00C1\u00C9\u00CD\u00D3\u00DA') // => 'AEIOU'\n * removeAccents('se\u00F1or') // => 'senor'\n * removeAccents('\u0152') // => 'OE'\n */\nexport function removeAccents(inputString) {\n  return inputString.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').replace(/\\\u0153/g, \"oe\").replace(/\\\u00E6/g, \"ae\").normalize('NFC')\n}\n\n/**\n * Strip HTML tags from a string\n * \n * @param {string} inputString\n * @returns string\n * @example\n * stripHTMLTags('<span>foo</span>') // => 'foo'\n * stripHTMLTags('<span>foo</span> <span>bar</span>') // => 'foo bar'\n */\nexport function stripHTMLTags(inputString) {\n  return inputString.replace(/<[^>]*>/g, '')\n}\n\n/**\n * Slugify a string, e.g. 'Foo Bar' => 'foo-bar'. Similar to WordPress' sanitize_title(). Will remove accents and HTML tags.\n * \n * @param {string} str \n * @returns string\n * @example\n * slugify('Foo Bar') // => 'foo-bar'\n * slugify('Foo Bar <span>baz</span>') // => 'foo-bar-baz'\n */\nexport function slugify(str) {\n  str = str.trim().toLowerCase()\n  str = removeAccents(str)\n  str = stripHTMLTags(str)\n  return str.replace(/\\s+|\\.+|\\/+|\\\\+|\u2014+|\u2013+/g, '-').replace(/[^\\w0-9\\-]+/g, '').replace(/-{2,}/g, '-').replace(/^-|-$/g, '')\n}\n\n/**\n * Check if object has multiple properties\n * \n * @param {object} obj\n * @param {string|array} properties\n * @returns boolean\n * @example\n * const obj = { foo: 'bar', baz: 'qux' }\n * hasOwnProperties(obj, ['foo', 'baz']) // => true\n * hasOwnProperties(obj, ['foo', 'baz', 'qux']) // => false\n */\nexport function hasOwnProperties(obj, properties) {\n  if(!isArray(properties)) properties = [properties]\n  for (let i = 0; i < properties.length; i++) {\n    if (!obj.hasOwnProperty(properties[i])) return false\n  }\n  return true\n}\n\n/**\n * Finds the closest number to the set goal in an array to a given number\n * \n * @param {number} goal Number to search for\n * @param {array} arr Array of numbers to search in\n * @returns number\n * @example\n * closestNumber(10, [1, 2, 3, 4, 5, 6, 7, 8, 9]) // => 9\n * closestNumber(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 11]) // => 9\n * closestNumber(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 9.5]) // => 9.5\n * closestNumber(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11) // => 10\n */\nexport function closestNumber(goal, arr) {\n  return arr.reduce(function(prev, curr) {\n    return Math.abs(curr - goal) < Math.abs(prev - goal) ? curr : prev\n  })\n}\n\n/**\n * Truncate a string to a given number of words\n * \n * @param {string} str String to truncate\n * @param {number} numWords Number of words to truncate to\n * @param {string} ellipsis Ellipsis to append to the end of the string\n * @returns string\n * @example\n * truncateString('foo bar baz', 2) // => 'foo bar\u2026'\n * truncateString('foo bar baz', 2, '...') // => 'foo bar...'\n * truncateString('foo bar. baz', 2, '...') // => 'foo bar. ...'\n */\nexport function truncateString(str, numWords, ellipsis = '\u2026') {\n  const words = str.trim().split(' ')\n  if (words.length <= numWords) return str\n  if (numWords <= 0) return ''\n  if (/[.?!]$/.test(words[numWords - 1]) && ellipsis.trim() !== '') ellipsis = ` ${ellipsis}`\n  return words.slice(0, numWords).join(' ') + ellipsis\n}\n\n/**\n * Generates a random integer between two values, inclusive of both\n * \n * @param {number} min Minimum value\n * @param {number} max Maximum value\n * @param {boolean} safe Defaults to false, if true will use a cryptographically secure random number generator\n * @returns number\n * @example\n * randomIntInclusive(1, 10) // => 1\n * randomIntInclusive(1, 10) // => 10\n * randomIntInclusive(1, 10) // => 5\n */\nexport function randomIntInclusive(min, max, safe = false) {\n  min = Number(min)\n  max = Number(max)\n  if (isNaN(min) || isNaN(max)) throw new TypeError('Both min and max must be numbers')\n  if (min > max) [min, max] = [max, min]\n  if (min === max) return min\n  min = Math.round(min)\n  max = Math.round(max)\n  const rand = safe ? random() : Math.random()\n  return Math.floor(rand * (max - min + 1)) + min\n}\n\n/**\n * Gets fixed number of digits after the decimal point\n * \n * @param {number} number Number to fix\n * @param {number} digits Number of digits to fix to\n * @returns number\n * @example\n * fixed(1.234, 2) // => 1.23\n * fixed(1.235, 2) // => 1.24\n * fixed(1.234) // => 1\n * fixed(1.234, 0) // => 1\n * fixed(1.234, 5) // => 1.234\n * @note Gotta ask myself why I wrote this function in the first place... \uD83E\uDD14 It's just not useful in a lot of cases lol...\n */\nexport function fixed(number, digits) {\n  if (!digits) return parseInt(number)\n  return parseFloat(number.toFixed(digits))\n}\n\n/**\n * Calculates the percentage of a number in relation to another number\n * \n * @param {number} num Number to calculate percentage of\n * @param {number} total Total number\n * @returns number\n * @example\n * percentage(1, 10) // => 10\n * percentage(5, 10) // => 50\n * percentage(10, 10) // => 100\n * percentage(0, 10) // => 0\n * percentage(10, 2) // => 500\n */\nexport function percentage(num, total) {\n  if (!num || !total || Number.isNaN(num) || Number.isNaN(total)) return 0\n  return num / total * 100\n}\n\nexport function pickProperties(obj, props) {\n  const res = {}\n  if (!props) return res\n  if (!isArray(props)) props = [props]\n  for (let i = 0; i < props.length; i++) {\n    if (obj.hasOwnProperty(props[i])) res[props[i]] = obj[props[i]]\n  }\n  return res\n}\n\nexport function rejectProperties(obj, props, clone = true) {\n  if (clone) obj = { ...obj }\n  if (!props) return obj\n  if (!isArray(props)) props = [props]\n  for (let i = 0; i < props.length; i++) {\n    if (obj.hasOwnProperty(props[i])) delete obj[props[i]]\n  }\n  return obj\n}\n\nexport function pickArrayElements(arr, indexes) {\n  if (!isArray(arr)) return\n  if (!isArray(indexes)) indexes = [indexes]\n  const res = []\n  for (let i = 0; i < indexes.length; i++) {\n    if (arr.hasOwnProperty(indexes[i])) res.push(arr[indexes[i]])\n  }\n  return res\n}\n\nexport function rejectArrayElements(arr, indexes, clone = true) {\n  if (clone) arr = [...arr]\n  if (!isArray(arr)) return\n  if (!isArray(indexes)) indexes = [indexes]\n  for (let i = indexes.length - 1; i >= 0; i--) {\n    if (arr.hasOwnProperty(indexes[i])) arr.splice(indexes[i], 1)\n  }\n  return arr\n}\n\n/**\n * Pick properties from an object or elements from an array\n * \n * @param {array} obj Object or array to pick properties or elements from\n * @param {array | string | number} props Properties to remove, can be an array of strings or a single string or number\n * @returns object | array | undefined\n * @example\n * \n * pick({ foo: 'bar', bar: 'baz', baz: 'qux' }) // => {}\n * pick({}, []) // => {}\n * pick(null, 'foo') // => undefined\n * pick({ foo: 'bar', bar: 'baz', baz: 'qux' }, undefined) // => {}\n * pick({ foo: 'bar', bar: 'baz', baz: 'qux' }, 'foo') // => { foo: 'bar'}\n * pick({ foo: 'bar', bar: 'baz', baz: 'qux' }, ['foo', 'baz']) // => { foo: 'bar', baz: 'qux' }\n * \n * pick(['foo', 'bar', 'baz'], []) // => []\n * pick([], []) // => []\n * pick(null, 0) // => undefined\n * pick(['foo', 'bar', 'baz'], undefined) // => []\n * pick(['foo', 'bar', 'baz'], 0) // => ['foo']\n * pick(['foo', 'bar', 'baz'], [0, 2]) // => ['foo', 'baz']\n * pick(['foo', 'bar', 'baz'], [0, 2, 3]) // => ['foo', 'baz']\n */\nexport function pick(obj, props) {\n  return isObject(obj) ? pickProperties(obj, props) : pickArrayElements(obj, props)\n}\n\n/**\n * Remove properties from an object or elements from an array\n * \n * @param {array} obj Object or array to remove properties or elements from\n * @param {array | string | number} props Properties to remove, can be an array of strings or a single string or number\n * @param {boolean} clone Defaults to true, will clone the object or array before removing properties or elements.\n * @returns object | array | undefined\n * @example\n * \n * reject({ foo: 'bar', bar: 'baz', baz: 'qux' }) // => {}\n * reject({}, []) // => {}\n * reject(null, 'foo') // => undefined\n * reject({ foo: 'bar', bar: 'baz', baz: 'qux' }, undefined) // => {}\n * reject({ foo: 'bar', bar: 'baz', baz: 'qux' }, 'foo') // => { bar: 'baz', baz: 'qux' }\n * reject({ foo: 'bar', bar: 'baz', baz: 'qux' }, ['foo', 'baz']) // => { bar: 'baz' }\n * \n * reject(['foo', 'bar', 'baz'], []) // => []\n * reject([], []) // => []\n * reject(null, 0) // => undefined\n * reject(['foo', 'bar', 'baz'], undefined) // => []\n * reject(['foo', 'bar', 'baz'], 0) // => ['bar', 'baz']\n * reject(['foo', 'bar', 'baz'], [0, 2]) // => ['bar']\n * reject(['foo', 'bar', 'baz'], [0, 2, 3]) // => ['bar']\n */\nexport function reject(obj, props, clone = true) {\n  return isObject(obj) ? rejectProperties(obj, props, clone) : rejectArrayElements(obj, props, clone)\n}\n\n/**\n * Basic timestamp first UID generator that's good enough for most use cases but not for security purposes.\n * There's an extremely small chance of collision, so create a map object to check for collisions if you're worried about that.\n * \n * - `Date.now().toString(16)` is used for the timestamp, which is a base16 representation of the current timestamp in milliseconds.\n * - `random().toString(16).substring(2)` is used for the random number, which is a base16 representation of a random number between 0 and 1, with the first two characters removed.\n * \n * @param {boolean} safe Defaults to false, if true will use a cryptographically secure random number generator for the random number improving security but reducing performance. If crypto is not available, will use Math.random() instead.\n * @returns string\n * @example\n * basicUID() // => '18d4613e4d2-750bf066ac6158'\n */\nexport function basicUID(safe = false) {\n  const rand = safe ? random() : Math.random()\n  return Date.now().toString(16)+'-'+rand.toString(16).substring(2)\n}\n\nfunction cryptoUUIDFallback() {\n  return '10000000-1000-4000-8000-100000000000'.replace(/[018]/g, c =>\n   (c ^ Math.random() * 16 >> c / 4).toString(16)\n  )\n}\n\n// Taken from https://stackoverflow.com/a/2117523/5437943\nfunction cryptoRandomUUIDFallback() {\n  return '10000000-1000-4000-8000-100000000000'.replace(/[018]/g, c =>\n    (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)\n  )\n}\n\n/**\n * Generates a UUID v4\n * - Uses crypto.randomUUID if available\n * - Uses crypto.getRandomValues if available\n * - Uses a fallback if neither is available, which is not safe because it uses Math.random() instead of a cryptographically secure random number generator\n * \n * I'm bad at crypto and bitwise operations, not my cup of tea, so I had to rely on StackOverflow for the fallback: https://stackoverflow.com/a/2117523/5437943\n * \n * @param {boolean} safe Defaults to true, if false will use a fallback that's not cryptographically secure but significantly faster\n * @returns string\n * @example\n * generateUUID() // UUID v4, example 09ed0fe4-8eb6-4c2a-a8d3-a862b7513294\n */\nexport function generateUUID(safe = true) {\n  if (!crypto || !safe) return cryptoUUIDFallback()\n  if (crypto.randomUUID) return crypto.randomUUID()\n  if (crypto.getRandomValues) return cryptoRandomUUIDFallback();\n}\n\n/**\n * Generates a random number between 0 and 1, inclusive of 0 but not inclusive of 1.\n * \n * - Uses crypto.getRandomValues if available\n * - Uses Math.random() if crypto.getRandomValues is not available\n * \n * @returns number\n * @example\n * random() // => 0.123456789\n */\nexport function random() {\n  if (!crypto) return Math.random()\n  if (crypto.getRandomValues) return crypto.getRandomValues(new Uint32Array(1))[0] / 4294967295 // 2^32 - 1 = 4294967295\n}\n", "/** @module dom */\n\nimport { transformDashToCamelCase, isArray, isString } from './helpers.mjs'\nimport { encodeHtmlEntities, decodeHtmlEntities } from './parsers.mjs'\n\n/**\n * Checks if an element is empty\n * \n * @param {HTMLElement} element \n * @returns boolean\n * @example\n * document.body.innerHTML = `\n *  <div id=\"empty-element\"></div>\n *  <div id=\"non-empty-element1\">foo</div>\n *  <div id=\"non-empty-element2\"><br></div>`\n * \n * isEmptyElement(document.getElementById('empty-element')) // => true\n * isEmptyElement(document.getElementById('non-empty-element1')) // => false\n * isEmptyElement(document.getElementById('non-empty-element2')) // => false\n */\nexport function isEmptyElement(element) {\n  return element.innerHTML.trim() === ''\n}\n\n/**\n * Removes all elements matching a selector from the DOM\n * \n * @param {string|HTMLElement|Element} selector The selector to select elements to remove\n * @param {HTMLElement|Element} [from=document] The element to remove elements from\n * @example\n * document.body.innerHTML = `\n * <div id=\"foo\"></div>\n * <div id=\"bar\"></div>\n * <div id=\"baz\"></div>`\n * `\n * remove('#foo, #bar') // => removes #foo and #bar\n */\nexport function remove(selector, from = document) {\n  const elements = query(selector, from)\n  for (const element of elements) {\n    element.remove()\n  }\n}\n\n/**\n * Queries the DOM for a single element and returns it. Substitutes for `document.querySelector(selector)` and JQuery's `$(selector).first()`\n * \n * @param {string|HTMLElement|Element|Array<HTMLElement|Element>|NodeList} selector The selector to select an element\n * @param {HTMLElement|Element} [from=document] The element to query from\n * @returns {HTMLElement|Element}\n * @example\n * document.body.innerHTML = `\n * <div id=\"foo\"></div>\n * <div id=\"bar\"></div>\n * <div id=\"baz\"></div>`\n * \n * querySingle('#foo') // => <div id=\"foo\"></div>\n * querySingle(document.getElementById('foo')) // => <div id=\"foo\"></div>\n * querySingle(document.querySelector('#foo')) // => <div id=\"foo\"></div>\n */\nexport function querySingle(selector, from = document) {\n  if (selector instanceof Element) return selector\n  return from.querySelector(selector)\n}\n\n/**\n * Queries the DOM for elements and returns them. Substitutes for `document.querySelectorAll(selector)` and JQuery's `$(selector)`\n * \n * @param {string|HTMLElement|Element|Array<HTMLElement|Element>|NodeList} selector The selector to select elements\n * @param {HTMLElement|Element} [from=document] The element to query from\n * @returns {Array<Element>|NodeList}\n * @example\n * document.body.innerHTML = `\n * <div id=\"foo\"></div>\n * <div id=\"bar\"></div>\n * <div id=\"baz\"></div>`\n * \n * query('#foo') // => [<div id=\"foo\"></div>]\n * query(document.getElementById('foo')) // => [<div id=\"foo\"></div>]\n * query('div') // => [<div id=\"foo\"></div>, <div id=\"bar\"></div>, <div id=\"baz\"></div>]\n */\nexport function query(selector, from = document) {\n  if (selector instanceof Array || selector instanceof NodeList) return selector\n  if (selector instanceof Element) return [selector]\n  if (from instanceof Element || from instanceof Document) return from.querySelectorAll(selector)\n  if (isString(from)) from = query(from)\n  if (!from instanceof Array  && !from instanceof NodeList) return []\n  const res = []\n  for (const element of from) {\n    res.push(...element.querySelectorAll(selector))\n  }\n  return res\n}\n\n/**\n * Sets element styles from passed object of styles. Can also transform dash-case to camelCase for CSS properties\n * \n * @param {HTMLElement} element The element to set styles on\n * @param {object} styles The object of styles to set\n * @param {boolean} transform Whether to transform dash-case to camelCase for CSS properties\n * @example\n * css(document.getElementById('foo'), { 'background-color': 'red', 'font-size': '16px' }, true) // => sets background-color and font-size\n * css(document.getElementById('foo'), { backgroundColor: 'red', fontSize: '16px' }) // => sets background-color and font-size\n */\nexport function css(element, styles, transform = false) {\n  if (!element || !styles) return\n  for (let property in styles) {\n    if (transform) property = transformDashToCamelCase(property)\n    element.style[property] = styles[property]\n  }\n}\n\n/**\n * Decodes HTML entities in a string using the browser's DOMParser. If the DOMParser is not available, it uses a regular expression to decode the basic entities.\n * \n * @see {@link module:parsers.decodeHtmlEntities}\n * \n * @param {string} html The HTML string to decode\n * @returns {string} The decoded HTML string\n * @example\n * decodeHTML('&lt;div&gt;foo&lt;/div&gt;') // => '<div>foo</div>'\n * decodeHTML('&lt;div&gt;foo&lt;/div&gt;&lt;div&gt;bar&lt;/div&gt;') // => '<div>foo</div><div>bar</div>'\n */\nexport function decodeHTML(html) {\n  if (typeof document === 'undefined') return decodeHtmlEntities(html)\n  const txt = document.createElement('textarea')\n  txt.innerHTML = html\n  const res = txt.value\n  txt.remove()\n  return res\n}\n\n/**\n * Encodes HTML entities in a string using the browser's DOMParser. If the DOMParser is not available, it uses a regular expression to encode the basic entities.\n * \n * @see {@link module:parsers.encodeHtmlEntities}\n * \n * @param {string} html The HTML string to encode\n * @returns {string} The encoded HTML string\n * @example\n * encodeHTML('<div>foo</div>') // => '&lt;div&gt;foo&lt;/div&gt;'\n * encodeHTML('<div>foo</div><div>bar</div>') // => '&lt;div&gt;foo&lt;/div&gt;&lt;div&gt;bar&lt;/div&gt;'\n */\nexport function encodeHTML(html) {\n  if (typeof document === 'undefined') return encodeHtmlEntities(html)\n  const txt = document.createElement('textarea')\n  txt.textContent = html\n  const res = txt.innerHTML\n  txt.remove()\n  return res\n}\n\n/**\n * Inserts an element before another element\n * \n * @param {HTMLElement} targetElement The element to insert before\n * @param {HTMLElement} newElement The element to insert\n * @example\n * const target = document.getElementById('target')\n * const newElement = document.createElement('div')\n * newElement.id = 'newElement'\n * insertBeforeElement(target, newElement)\n * // <div id=\"newElement\"></div>\n * // <div id=\"target\"></div>\n */\nexport function insertBeforeElement(targetElement, newElement) {\n  if (!targetElement || !newElement) return\n  targetElement.parentNode.insertBefore(newElement, targetElement);\n}\n\n/**\n * Toggles an attribute value on an element\n * \n * @param {HTMLElement} element The element to toggle the attribute on\n * @param {string} attribute The attribute to toggle\n * @param {string} on Default: 'true'\n * @param {string} off Default: 'false'\n * @example\n * toggleAttributeValue(element, 'aria-expanded', 'true', 'false')\n * toggleAttributeValue(element, 'aria-expanded')\n */\nexport function toggleAttributeValue(element, attribute, on = 'true', off = 'false') {\n  if (!element.hasAttribute(attribute)) return\n\n  if (element.getAttribute(attribute) === on) {\n    element.setAttribute(attribute, off)\n  } else {\n    element.setAttribute(attribute, on)\n  }\n}\n\n/**\n * Converts a duration string to milliseconds integer\n * \n * @param {string} duration The duration string to convert, e.g. '1s', '100ms', '0.5s'\n * @returns {number} The duration in milliseconds\n * @example\n * convertToMilliseconds('1s') // 1000\n * convertToMilliseconds('100ms') // 100\n * convertToMilliseconds('0.5s') // 500\n * convertToMilliseconds('0.5') // 0\n * convertToMilliseconds('foo') // 0\n */\nexport function cssTimeToMilliseconds(duration) {\n  const regExp = new RegExp('([0-9.]+)([a-z]+)', 'i')\n  const matches = regExp.exec(duration)\n  if (!matches) return 0\n  \n  const unit = matches[2]\n  switch (unit) {\n    case 'ms':\n      return parseFloat(matches[1])\n    case 's':\n      return parseFloat(matches[1]) * 1000\n    default:\n      return 0\n  }\n}\n\n/**\n * Returns a map of transition properties and durations\n * \n * @param {HTMLElement} element The element to get the transition properties and durations from\n * @returns {object<string, number>} A map of transition properties and durations\n * @example\n * getTransitionDurations(element) // { height: 1000 } if transition in CSS is set to 'height 1s'\n * getTransitionDurations(element) // { height: 500, opacity: 1000 } if transition in CSS is set to 'height 0.5s, opacity 1s'\n */\nexport function getTransitionDurations(element) {\n  if (!element) {}\n  const styles = getComputedStyle(element)\n  const transitionProperties = styles.getPropertyValue('transition-property').split(',')\n  const transitionDurations = styles.getPropertyValue('transition-duration').split(',')\n  \n  const map = {}\n  \n  for (let i = 0; i < transitionProperties.length; i++) {\n    const property = transitionProperties[i].trim()\n    map[property] = transitionDurations.hasOwnProperty(i) ? cssTimeToMilliseconds(transitionDurations[i].trim()) : null\n  }\n  \n  return map\n}\n\n/**\n * Check a list of elements if any of them matches a selector\n * \n * @param {Array<HTMLElement>|NodeList|HTMLElement} elements The elements to check\n * @param {string} selector The selector to check\n * @returns {boolean} True if any of the elements matches the selector, false otherwise\n * @example\n * document.body.innerHTML = `\n * <div id=\"foo\"></div>\n * <div id=\"bar\"></div>\n * <div id=\"baz\"></div>`\n * \n * matchesAny(document.querySelectorAll('div'), '#foo') // => true\n * matchesAny(document.querySelectorAll('div'), '#qux') // => false\n */\nexport function matchesAny(elements, selector) {\n  if (!elements || !selector || !elements.length) return false\n  if (elements instanceof Element) elements = [elements]\n  if (isString(elements)) elements = query(elements)\n  for (const element of elements) {\n    if (element.matches(selector)) return true\n  }\n  return false\n}\n\n/**\n * Check a list of elements if all of them matches a selector\n * \n * @param {Array<HTMLElement>|NodeList|HTMLElement} elements The elements to check\n * @param {string} selector The selector to check\n * @returns {boolean} True if all of the elements matches the selector, false otherwise\n * @example\n * document.body.innerHTML = `\n * <div id=\"foo\"></div>\n * <div id=\"bar\"></div>\n * <div id=\"baz\"></div>`\n * \n * matchesAll(document.querySelectorAll('div'), 'div') // => true\n * matchesAll(document.querySelectorAll('div'), '#foo') // => false\n */\nexport function matchesAll(elements, selector) {\n  if (!elements || !selector || !elements.length) return false\n  if (elements instanceof Element) elements = [elements]\n  if (isString(elements)) elements = query(elements)\n  for (const element of elements) {\n    if (!element.matches(selector)) return false\n  }\n  return true\n}\n\n\n/**\n * Detaches an element from the DOM and returns it\n * \n * @param {HTMLElement} element The element to detach\n * @example\n * detachElement(element)\n * // => element\n * console.log(element.parentNode) // => null\n */\nexport function detachElement(element) {\n  if (element && element.parentNode) {\n    element.parentNode.removeChild(element);\n  }\n  return element\n}\n\n/**\n * Gets table data from a table element, a simple regular table element, or a table like structure.\n * Useful for scraping data.\n * \n * @param {string} selector The selector to select the table element\n * @param {Array<string>|string|null} headers The headers to use for the data. If 'auto' is passed, the row containing th or the first row will be used as headers\n * @param {string} [rowSelector='tr'] The selector to select the rows\n * @param {string} [cellSelector='td'] The selector to select the cells\n * @returns {Array<object>} An array of objects with the properties as keys and the cell values as values\n * @example\n * document.body.innerHTML = `\n * <table id=\"table\">\n *  <thead>\n *   <tr>\n *   <th>Foo</th>\n *  <th>Bar</th>\n * </tr>\n * </thead>\n * <tbody>\n * <tr>\n * <td>Foo 1</td>\n * <td>Bar 1</td>\n * </tr>  \n * <tr>\n * <td>Foo 2</td>\n * <td>Bar 2</td>\n * </tr>\n * </tbody>\n * </table>`\n * \n * getTableData('#table', ['foo', 'bar'])\n * // => [\n * //  { foo: 'Foo 1', bar: 'Bar 1' },\n * //  { foo: 'Foo 2', bar: 'Bar 2' }\n * // ]\n */\nexport function getTableData(selector, headers, rowSelector = 'tr', cellSelector = 'td', headerCellSelector = 'th') {\n  const table = typeof selector === 'string' ? document.querySelector(selector) : selector\n  const res = []\n  const rows = table.querySelectorAll(rowSelector)\n  let start = 0\n\n  function iterateHeaders(arr) {\n    if (!arr || !arr.length) return\n    const res = []\n    for (let i = 0; i < arr.length; i++) {\n      res.push(arr[i].textContent.trim())\n    }\n    return res\n  }\n\n  if (headers && isString(headers) && headers === 'auto') {\n    let headerCells = table.querySelectorAll(headerCellSelector)\n    \n    if (headerCells && headerCells.length) {\n      headers = iterateHeaders(headerCells)\n    } else {\n      headers = iterateHeaders(rows[0].querySelectorAll(cellSelector))\n      start = 1\n    }\n  }\n\n  for (let i = start; i < rows.length; i++) {\n    const row = rows[i]\n    const cells = row.querySelectorAll(cellSelector)\n    if (!cells || !cells.length) continue\n\n    let rowData = []\n    if (headers && isArray(headers) && headers.length) {\n      rowData = {}\n      for (let j = 0; j < headers.length; j++) {\n        rowData[headers[j]] = cells[j] ? cells[j].textContent.trim() : null\n      }\n    } else {\n      for (let j = 0; j < cells.length; j++) {\n        rowData.push(cells[j].textContent.trim())\n      }\n    }\n    res.push(rowData)\n  }\n  return res\n}\n\n/**\n * Parses HTML string to a DOM Node\n * \n * @param {string} html The HTML string to parse\n * @param {boolean} [allChildren=false] If true, all children of the body will be returned, otherwise only the first child\n * @returns {Node} The parsed DOM Node\n * @example\n * parseDOM('<div>foo</div>') // => <div>foo</div>\n * parseDOM('<div>foo</div><div>bar</div>', true) // => NodeList(2)\u00A0[div, div]\n * parseDOM(document.getElementById('foo')) // => <div id=\"foo\"></div>\n * parseDOM(document.querySelectorAll('div')) // => NodeList(2)\u00A0[div, div]\n */\nexport function parseDOM(html, allChildren) {\n  if (html instanceof Element || html instanceof NodeList) return html\n  const parser = new DOMParser()\n  const doc = parser.parseFromString(html, 'text/html')\n  return !allChildren ? doc.body.firstChild : doc.body.childNodes\n}\n\n/**\n * Loads an image form a provided source url and calls a callback when it's loaded\n * \n * @param {string} src The source url of the image\n * @param {Function} [callback] The callback to call when the image is loaded\n * @example\n * loadImage('https://example.com/image.png', () => {\n *  console.log('Image loaded')\n * })\n */\nexport function loadImage(src, callback) {\n  const img = new Image()\n  if (callback)\n    img.addEventListener('load', callback, false);\n  img.src = src\n}\n\n/**\n * Delegate DOM events using MutationObserver with a fallback to document.addEventListener\n * \n * @param {string} selector The selector to select the elements to delegate the event to\n * @param {string} eventType The event type to delegate, like `click`\n * @param {Function} handler The handler to call when the event is triggered.\n * @returns {MutationObserver | null} The MutationObserver instance\n * @example\n * delegateEvent('.foo', 'click', (e, target) => {\n * console.log('Clicked on', target)\n * })\n */\nexport function delegateEvent(selector, eventType, handler) {\n  if (typeof MutationObserver === 'undefined') {\n    document.addEventListener(eventType, (e) => {\n      const target = e.target.closest(selector)\n      if (target) handler(e, target)\n    })\n\n    return null\n  }\n\n  const observer = new MutationObserver((mutations) => {\n    for (const mutation of mutations) {\n      for (const node of mutation.addedNodes) {\n        if (!(node instanceof HTMLElement)) continue\n        if (!node.matches(selector)) continue\n        node.addEventListener(eventType, (e) => {\n          handler(e, e.currentTarget)\n        })\n      }\n    }\n  })\n\n  for (const node of document.querySelectorAll(selector)) {\n    node.addEventListener(eventType, (e) => {\n      handler(e, e.currentTarget)\n    })\n  }\n\n  observer.observe(document.body, { childList: true, subtree: true })\n  return observer\n}\n\n/**\n * Run a handler on selected elements and on elements added to the DOM with the same selector, \n * or can be delegateEvent alias.\n * \n * @param {string} selector The selector to select the elements to run the handler on\n * @param {string | Function} eventTypeOrHandler The event type to delegate, like `click`, or the handler to call on every element\n * @param {Function} [handler] The handler to call when the event is triggered.\n * @returns {MutationObserver | null} The MutationObserver instance\n * @see delegateEvent\n * @example\n * on('.foo', (el) => {\n * console.log('Element', el, 'added to the DOM')\n * })\n * \n * on('.foo', 'click', (e, target) => {\n * console.log('Clicked on', target)\n * })\n */\nexport function on(selector, eventTypeOrHandler, handler) {\n  if (isString(eventTypeOrHandler)) {\n    return delegateEvent(selector, eventTypeOrHandler, handler)\n  }\n\n  const observer = new MutationObserver((mutations) => {\n    for (const mutation of mutations) {\n      for (const node of mutation.addedNodes) {\n        if (!(node instanceof HTMLElement)) continue\n        if (!node.matches(selector)) continue\n        eventTypeOrHandler(node)\n      }\n    }\n  })\n\n  for (const node of document.querySelectorAll(selector)) {\n    eventTypeOrHandler(node)\n  }\n\n  observer.observe(document.body, { childList: true, subtree: true })\n\n  return observer\n}\n\n/**\n * Adds one listener to multiple events\n * \n * @param {string|HTMLElement|NodeList} elements The elements or a selector for elements to add the event listeners to\n * @param {string|Array<string>} events The event types to add the event listeners for, like `click mouseenter`\n * @param {Function} handler The handler to call when the event is triggered.\n * @param {object} [options] The options to pass to the event listeners\n * @example\n * addListenerForEvents('.foo', 'click mouseenter', (e) => { console.log(e.type) })\n */\nexport function addListenerForEvents(elements, events, handler, options) {\n  if (elements instanceof Element) elements = [elements]\n  if (typeof elements === 'string') elements = query(elements)\n\n  const eventTypes = isArray(events) ? events : events.split(' ')\n  for (const element of elements) {\n    for (const eventType of eventTypes) {\n      element.addEventListener(eventType, handler, options)\n    }\n  }\n}\n\n/**\n * Removes one listener from multiple registered events\n * \n * @param {string|HTMLElement|NodeList} elements The elements or a selector for elements to remove the event listeners from\n * @param {string|Array<string>} events The event types to remove the event listeners for, like `click mouseenter`\n * @param {Function} handler The handler to remove\n * @param {object} [options] The options to pass to the event listeners\n * @example\n * removeListenerForEvents('.foo', 'click mouseenter', (e) => { console.log(e.type) })\n */\nexport function removeListenerForEvents(elements, events, handler, options) {\n  if (elements instanceof Element) elements = [elements]\n  if (typeof elements === 'string') elements = query(elements)\n\n  const eventTypes = isArray(events) ? events : events.split(' ')\n  for (const element of elements) {\n    for (const eventType of eventTypes) {\n      element.removeEventListener(eventType, handler, options)\n    }\n  }\n}\n\n/**\n * Resizes an element to cover its parent element while maintaining the aspect ratio\n * \n * @param {string|HTMLElement|NodeList} elements The elements or a selector for elements to resize\n * @param {number} [ratio=1] The ratio to maintain\n * @param {number} [offset=0] An offset to add to the parent element's width and height\n * @example\n * proportionalParentCoverResize('.foo', 16/9, 10)\n */\nexport function proportionalParentCoverResize(elements, ratio = 1, offset = 0) {\n  if (elements instanceof Element) elements = [elements]\n  if (typeof elements === 'string') elements = query(elements)\n\n  for (const element of elements) {\n    const h = element.parentNode.offsetHeight + offset\n    const w = element.parentNode.offsetWidth + offset\n\n    if (ratio > w/h) {\n      element.style.width = h*ratio + 'px'\n      element.style.height = h + 'px'\n    } else {\n      element.style.width = w + 'px'\n      element.style.height = w/ratio + 'px'\n    }\n  }\n}\n\n/**\n * If provided element is visible. Checks if the element is not visibility hidden or display none, has no opacity, and has a width and height.\n * \n * @param {HTMLElement} element The element to check\n * @returns {boolean} True if the element is visible, false otherwise\n * \n * @example\n * isVisible(document.getElementById('foo'))\n */\nexport function isVisible(element) {\n  if (!element) return false;\n  const computedStyle = getComputedStyle(element);\n  if (computedStyle.getPropertyValue('display') === 'none') return false;\n  if (element.getAttribute('hidden') !== null || computedStyle.getPropertyValue('visibility') === 'hidden' || computedStyle.getPropertyValue('opacity') == \"0\") return false;\n  return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length)\n}\n\n/**\n * Swipe event handler\n * \n * @param {HTMLElement} element The element to listen for swipe gestures on\n * @param {Function} callback The callback to call when a swipe gesture is detected\n * @param {number} [threshold=150] The threshold in pixels to trigger the callback.\n * @param {number} [timeThreshold=0] The threshold in milliseconds to trigger the callback. Defaults to 0, which means the callback will be called regardless of the time it took to swipe.\n * @event swipestart Fires when a swipe gesture starts\n * @event swipeend Fires when a swipe gesture ends\n * @event swipe Fires when a swipe gesture is detected based on the thresholds\n * @example\n * onSwipe(document.getElementById('foo'), (e) => {\n *  console.log(e.direction)\n *  console.log(e.deltaX)\n *  console.log(e.deltaY)\n *  console.log(e.startX)\n *  console.log(e.startY)\n *  console.log(e.endX)\n *  console.log(e.endY)\n *  console.log(e.threshold)\n *  console.log(e.type)\n *  console.log(e.target)\n *  console.log(e.horizontal)\n *  console.log(e.vertical)\n *  console.log(e.horizontalDirection)\n *  console.log(e.verticalDirection)\n *  console.log(e.timeElapsed)\n *  console.log(e.timeThreshold)\n * })\n */\nexport function onSwipe(element, callback, threshold = 150, timeThreshold = 0) {\n  let startX = 0\n  let startY = 0\n  let endX = 0\n  let endY = 0\n  let startTime = 0\n  let endTime = 0\n\n  if (!element) return\n  if (element.getAttribute('swipe-enabled') === 'true') return\n  element.setAttribute('swipe-enabled', 'true')\n\n  const handleStart = function(e) {\n    const carrier = e.touches ? e.touches[0] : e\n    startX = carrier.clientX\n    startY = carrier.clientY\n    startTime = Date.now();\n    element.dispatchEvent(new CustomEvent('swipestart', { detail: { startX, startY, startTime } }))\n  }\n\n  const handleEnd = function(e) {\n    const carrier = e.changedTouches ? e.changedTouches[0] : e\n    endX = carrier.clientX\n    endY = carrier.clientY\n    endTime = Date.now();\n    handleSwipeGesture()\n    element.dispatchEvent(new CustomEvent('swipeend', { detail: { startX, startY, startTime, endX, endY, endTime } }))\n  }\n\n  const handleSwipeGesture = function() {\n    const deltaX = Math.abs(endX - startX)\n    const deltaY = Math.abs(endY - startY)\n    const horizontal = deltaX > threshold\n    const vertical = deltaY > threshold\n    const left = endX < startX\n    const up = endY < startY\n    const direction = []\n    const timeElapsed = endTime - startTime;\n    \n    if (horizontal) direction.push(left ? 'left' : 'right')\n    if (vertical) direction.push(up ? 'up' : 'down')\n\n    let condition = direction.length && callback\n    if (timeThreshold) condition = condition && timeElapsed <= timeThreshold\n    \n    if (condition) {\n      const res = {\n        target: element,\n        deltaX: deltaX,\n        deltaY: deltaY,\n        startX: startX,\n        startY: startY,\n        endX: endX,\n        endY: endY,\n        threshold: threshold,\n        horizontal: horizontal,\n        vertical: vertical,\n        horizontalDirection: left ? 'left' : 'right',\n        verticalDirection: up ? 'up' : 'down',\n        direction: direction.length === 1 ? direction[0] : direction,\n        timeElapsed: timeElapsed,\n        timeThreshold: timeThreshold\n      }\n\n      callback(res)\n      delete res.target\n      element.dispatchEvent(new CustomEvent('swipe', { detail: res })) \n    }\n  }\n\n  element.addEventListener('touchstart', handleStart)\n  element.addEventListener('touchend', handleEnd)\n  element.addEventListener('mousedown', handleStart)\n  element.addEventListener('mouseup', handleEnd)\n\n  return {\n    destroy: function() {\n      element.removeEventListener('touchstart', handleStart)\n      element.removeEventListener('touchend', handleEnd)\n      element.removeEventListener('mousedown', handleStart)\n      element.removeEventListener('mouseup', handleEnd)\n    }\n  }\n}\n", "import { shallowMerge, getTransitionDurations, onSwipe, insertBeforeElement } from 'book-of-spells'\n\n/**\n * @name Slideswap\n * @description A simple slideshow that cross fades between slides.\n * @param {HTMLElement} element - The element to initialize as a slideshow\n * @param {Object} options - The options for the slideshow\n * @param {Boolean} [options.infinite=false] - Whether or not the slideshow should loop infinitely\n * @param {String} [options.activeClass='slideswap-current-slide'] - The class to apply to the current slide\n * @param {String} [options.slideSelector='.js-slideswap'] - The selector for the slides\n * @param {Number} [options.start=0] - The index of the slide to start on\n * @param {Boolean} [options.adaptiveHeight=true] - Whether or not the slideshow should adapt to the height of the current slide\n * @param {HTMLElement|String} [options.next=null] - The element to use as the next button or selector for the next button\n * @param {HTMLElement|String} [options.prev=null] - The element to use as the previous button or selector for the previous button\n * @param {String} [options.imageSelector='.js-slideswap-image'] - The selector for the images in the slides\n * @param {Boolean} [options.swipe=true] - Whether or not the slideshow should be swipeable\n * @param {String} [options.swipeClass='slideswap-has-swipe'] - The class to apply to the slideshow when it is swipeable\n * @param {String} [options.swipeActiveClass='slideswap-swipe-active'] - The class to apply to the slideshow when it is being swiped\n * @param {Number} [options.swipeThreshold=100] - The minimum distance the swipe must travel to trigger a slide change\n * @param {Number} [options.swipeTimeThreshold=1000] - The maximum amount of time the swipe can take to trigger a slide change in milliseconds. 0 disables this.\n * @returns {Slideswap} The initialized slideshow\n * @example\n * const slideshows = document.querySelectorAll('.js-slideshow')\n * for (let i = 0; i < slideshows.length; i++) {\n *  const slideshow = new Slideswap(slideshows[i], {\n *    infinite: true,\n *  })\n * \n *  // slideshow.next()\n *  // slideshow.previous()\n *  // slideshow.getCurrentIndex()\n *  // slideshow.getCurrentSlide()\n *  // slideshow.addSlide(slide)\n *  // slideshow.removeSlide(index)\n *  // slideshow.destroy()\n * }\n * @todo bullet navigation\n * @todo autoplay\n * @todo events\n */\nexport default class Slideswap {\n  constructor(element, options) {\n    this.element = element\n    this.currentIndex = 0\n    this.slides = null\n    this.maxHeight = 0\n    this.options = {\n      infinite: false,\n      activeClass: 'slideswap-current-slide',\n      slideSelector: '.js-slideswap',\n      start: 0,\n      adaptiveHeight: true,\n      next: null,\n      prev: null,\n      imageSelector: '.js-slideswap-image',\n      swipe: true,\n      swipeClass: 'slideswap-has-swipe',\n      swipeActiveClass: 'slideswap-swipe-active',\n      swipeThreshold: 100,\n      swipeTimeThreshold: 1000\n    }\n\n    if (typeof element === 'string') this.element = document.querySelector(element)\n\n    if (!this.element || !(this.element instanceof HTMLElement)) {\n      throw new Error('slideswap: element property not provided, or element not found')\n    }\n\n    if (this.element.getAttribute('data-slideswap-initialized') === 'true') {\n      throw new Error('slideswap: element already initialized')\n    }\n\n    this.transitionHeightDuration = getTransitionDurations(this.element)\n    this.transitionHeightTimer = null\n\n    shallowMerge(\n      this.options,\n      options\n    )\n\n    this.bindControls()\n\n    this.slides = this.element.querySelectorAll(this.options.slideSelector)\n    this.setCurrentSlide(this.options.start)\n    this.element.setAttribute('data-slideswap-initialized', 'true')\n\n    this.setupSlides()\n    \n    if (this.options.swipe) this.setupSwipe()\n  }\n\n  setupSwipe() {\n    onSwipe(this.element, (e) => {\n      if (!e.horizontal) return\n      e.horizontalDirection === 'left' ? this.next() : this.previous()\n    }, this.options.swipeThreshold, this.options.swipeTimeThreshold)\n\n    this.element.addEventListener('swipestart', () => {\n      this.element.classList.add(this.options.swipeActiveClass)\n    })\n\n    this.element.addEventListener('swipeend', () => {\n      this.element.classList.remove(this.options.swipeActiveClass)\n    })\n\n    this.element.classList.add(this.options.swipeClass)\n  }\n\n  bindControls() {\n    if (!this.options.next && !this.options.prev) return\n    this.options.next = typeof this.options.next === 'string' ? document.querySelector(this.options.next) : this.options.next\n    this.options.prev = typeof this.options.prev === 'string' ? document.querySelector(this.options.prev) : this.options.prev\n\n    if (this.options.next) this.options.next.addEventListener('click', this.next.bind(this))\n    if (this.options.prev) this.options.prev.addEventListener('click', this.previous.bind(this))\n  }\n\n  setupSlides() {\n    if (!this.slides || !this.slides.length) return\n    for (let i = 0; i < this.slides.length; i++) {\n      const slide = this.slides[i]\n      slide.setAttribute('data-slideswap-index', i)\n      this.maxHeight = Math.max(this.maxHeight, slide.offsetHeight)\n\n      slide.style.top = 0\n      slide.style.left = 0\n      slide.style.width = '100%'\n      slide.style.height = 'auto'\n      slide.style.overflow = 'hidden'\n\n      if (i === this.currentIndex) {\n        slide.style.position = 'relative'\n      } else {\n        slide.style.position = 'absolute'\n        slide.style.opacity = 0\n        slide.style.pointerEvents = 'none'\n      }\n\n      if (this.options.swipe) {\n        const slideImages = slide.querySelectorAll(`img`)\n        for (let i = 0; i < slideImages.length; i++) {\n          const image = slideImages[i]\n          image.draggable = false\n          image.setAttribute('draggable', 'false')\n        }\n      }\n    }\n\n    if (!this.options.adaptiveHeight) {\n      this.element.style.height = `${this.maxHeight}px`\n    }\n  }\n\n  setCurrentSlide(index) {\n    if (!this.slides || !this.slides.length) return\n    if (this.transitionHeightTimer) {\n      clearTimeout(this.transitionHeightTimer)\n      this.transitionHeightTimer = null\n    }\n    if (index === undefined || index === null) return\n    if (index < 0 || index >= this.slides.length) return\n    \n    if (this.options.adaptiveHeight) this.element.style.height = `${this.slides[this.currentIndex].offsetHeight}px`\n\n    this.currentIndex = index\n    this.element.setAttribute('data-slideswap-current-index', this.currentIndex)\n    const currentSlide = this.slides[index]\n    currentSlide.classList.add(this.options.activeClass)\n    currentSlide.removeAttribute('aria-hidden')\n    currentSlide.setAttribute('tabindex', '0')\n    currentSlide.style.zIndex = 1\n    currentSlide.style.opacity = 1\n    currentSlide.style.pointerEvents = 'auto'\n    currentSlide.style.position = 'absolute'\n    let reset = false\n\n    if (this.options.adaptiveHeight) {\n      this.element.style.height = `${currentSlide.offsetHeight}px`\n\n      const image = this.getCurrentSlide().querySelector(this.options.imageSelector)\n      if (image) {\n        image.addEventListener('load', () => {\n          if (!reset) this.element.style.height = `${currentSlide.offsetHeight}px`\n        })\n      }\n   \n      this.transitionHeightTimer = setTimeout(() => {\n        currentSlide.style.position = 'relative'\n        this.element.style.height = 'initial'\n        reset = true\n        this.transitionHeightTimer = null\n      }, this.transitionHeightDuration['height'])\n    }\n\n    for (let i = 0; i < this.slides.length; i++) {\n      const slide = this.slides[i]\n      if (i === index) continue\n      slide.classList.remove(this.options.activeClass)\n      slide.setAttribute('aria-hidden', 'true')\n      slide.setAttribute('tabindex', '-1')\n      slide.style.zIndex = 0\n      slide.style.opacity = 0\n      slide.style.pointerEvents = 'none'\n      slide.style.position = 'absolute'\n    }\n  }\n\n  getCurrentIndex() {\n    if (!this.slides || !this.slides.length) return\n    return this.currentIndex\n  }\n\n  getCurrentSlide() {\n    if (!this.slides || !this.slides.length) return\n    return this.slides[this.currentIndex]\n  }\n\n  getNextIndex() {\n    if (!this.slides || !this.slides.length) return\n    const nextIndex = this.currentIndex + 1\n    if (this.options.infinite && nextIndex >= this.slides.length) return 0\n    if (nextIndex >= this.slides.length) return this.currentIndex\n    return nextIndex\n  }\n\n  getPreviousIndex() {\n    if (!this.slides || !this.slides.length) return\n    const previousIndex = this.currentIndex - 1\n    if (this.options.infinite && previousIndex < 0) return this.slides.length - 1\n    if (previousIndex < 0) return this.currentIndex\n    return previousIndex\n  }\n\n  next() {\n    this.setCurrentSlide(this.getNextIndex())\n  }\n\n  previous() {\n    this.setCurrentSlide(this.getPreviousIndex())\n  }\n\n  destroy() {\n    this.element = null\n    this.slides = null\n    this.options = null\n    this.currentIndex = null\n    this.maxHeight = null\n\n    if (this.options.next) this.options.next.removeEventListener('click', this.next.bind(this))\n    if (this.options.prev) this.options.prev.removeEventListener('click', this.previous.bind(this))\n  }\n\n  add(slide, index) {\n    if (!slide || !(slide instanceof HTMLElement)) return\n    if (!this.slides) this.slides = []\n    if (index === undefined || index === null) index = this.slides.length\n    if (index < 0) return\n\n    slide.style.opacity = 0\n\n    if (index > this.slides.length) {\n      this.element.appendChild(slide)\n    } else {\n      if (this.slides[index])\n        insertBeforeElement(this.slides[index], slide)\n      else\n        this.element.appendChild(slide)\n    }\n\n    this.slides = this.element.querySelectorAll(this.options.slideSelector)\n\n    if (index <= this.currentIndex) {\n      const nextIndex = this.currentIndex + 1\n      this.currentIndex = nextIndex >= this.slides.length ? this.slides.length - 1 : nextIndex\n    }\n\n    this.setupSlides()\n    this.setCurrentSlide(this.currentIndex)\n  }\n\n  remove(index) {\n    if (!this.slides || !this.slides.length) return\n    this.element.removeChild(this.slides[index])\n    this.slides = this.element.querySelectorAll(this.options.slideSelector)\n\n    if (index <= this.currentIndex) {\n      const previousIndex = this.currentIndex - 1\n      this.currentIndex = previousIndex < 0 ? 0 : previousIndex\n    }\n\n    this.setupSlides()\n    this.setCurrentSlide(this.currentIndex)\n  }\n}\n", "import Slideswap from '../slideswap.js';\n\nif (!window.Slideswap) {\n  window.Slideswap = Slideswap;\n}\n"],
  "mappings": "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",
  "names": ["i"]
}
