{
  "version": 3,
  "sources": ["../node_modules/book-of-spells/src/helpers.mjs", "../slideswap.js", "../build/iife.js"],
  "sourcesContent": ["/**\n * Shallow merges two objects together. Used to pass simple options to functions.\n * \n * @param {object} target The target object to merge into\n * @param {object} source The source object to merge from\n * @returns object The merged object, in this case the target object with the source object's properties merged into it\n * @example\n * const target = { foo: 'bar' }\n * const source = { bar: 'baz' }\n * shallowMerge(target, source) // { foo: 'bar', bar: 'baz' }\n */\nexport function shallowMerge(target, source) {\n  for (const key in source) {\n    target[key] = source[key]\n  }\n\n  return target\n}\n\n/**\n * Deep merge function that's mindful of arrays and objects\n * \n * @param {object} target The target object to merge into\n * @param {object} source The source object to merge from\n * @returns object The merged object, in this case the target object with the source object's properties merged into it\n * @example\n * const target = { foo: 'bar' }\n * const source = { bar: 'baz' }\n * deepMerge(target, source) // { foo: 'bar', bar: 'baz' }\n */\nexport function deepMerge(target, source) {\n  if (isObject(source) && isObject(target)) {\n    for (const key in source) {\n      target[key] = deepMerge(target[key], source[key])\n    }\n  } else if (isArray(source) && isArray(target)) {\n    for (let i = 0; i < source.length; i++) {\n      target[i] = deepMerge(target[i], source[i])\n    }\n  } else {\n    target = source\n  }\n  return target\n}\n\n/**\n * Deep clone function that's mindful of nested arrays and objects\n * \n * @param {object} o The object to clone\n * @returns object The cloned object\n * @example\n * const obj = { foo: 'bar' }\n * const clone = clone(obj)\n * clone.foo = 'baz'\n * console.log(obj.foo) // 'bar'\n * console.log(clone.foo) // 'baz'\n * console.log(obj === clone) // false\n * console.log(JSON.stringify(obj) === JSON.stringify(clone)) // true\n * @todo Check if faster than assign. This function is pretty old...\n */ \nexport function clone(o) {\n  let res = null\n  if (isArray(o)) {\n    res = []\n    for (const i in o) {\n      res[i] = clone(o[i])\n    }\n  } else if (isObject(o)) {\n    res = {}\n    for (const i in o) {\n      res[i] = clone(o[i])\n    }\n  } else {\n    res = o\n  }\n  return res\n}\n\n/**\n * Check if an object is empty\n * \n * @param {object} o The object to check\n * @returns boolean True if the object is empty, false otherwise\n * @example\n * isEmptyObject({}) // => true\n * isEmptyObject({ foo: 'bar' }) // => false\n */\nexport function isEmptyObject(o) {\n  for (const i in o) {\n    return false\n  }\n  return true\n}\n\n/**\n * Check if an array is empty, substitute for Array.length === 0\n * \n * @param {array} o The array to check\n * @returns boolean True if the array is empty, false otherwise\n * @example\n * isEmptyArray([]) // => true\n * isEmptyArray([1, 2, 3]) // => false\n */\nexport function isEmptyArray(o) {\n  return o.length === 0\n}\n\n/**\n * Check if a variable is empty\n * \n * @param {any} o The variable to check\n * @returns boolean True if the variable is empty, false otherwise\n * @example\n * isEmpty({}) // => true\n * isEmpty([]) // => true\n * isEmpty('') // => true\n * isEmpty(null) // => false\n * isEmpty(undefined) // => false\n * isEmpty(0) // => false\n */\nexport function isEmpty(o) {\n  if (isObject(o)) {\n    return isEmptyObject(o)\n  } else if (isArray(o)) {\n    return isEmptyArray(o)\n  } else if (isString(o)) {\n    return o === ''\n  }\n  return false\n}\n\n/**\n * Try to convert a string to a boolean\n * \n * @param {string} str The string to convert\n * @returns boolean The converted boolean or undefined if conversion failed\n * @example\n * stringToBoolean('true') // => true\n * stringToBoolean('false') // => false\n * stringToBoolean('foo') // => null\n */\nexport function stringToBoolean(str) {\n  if (/^\\s*(true|false)\\s*$/i.test(str)) return str === 'true'\n}\n\n/**\n * Try to convert a string to a number\n * \n * @param {string} str The string to convert\n * @returns number The converted number or undefined if conversion failed\n * @example\n * stringToNumber('1') // => 1\n * stringToNumber('1.5') // => 1.5\n * stringToNumber('foo') // => null\n * stringToNumber('1foo') // => null\n */\nexport function stringToNumber(str) {\n  if (/^\\s*\\d+\\s*$/.test(str)) return parseInt(str)\n  if (/^\\s*[\\d.]+\\s*$/.test(str)) return parseFloat(str)\n}\n\n/**\n * Try to convert a string to an array\n * \n * @param {string} str The string to convert\n * @returns array The converted array or undefined if conversion failed\n * @example\n * stringToArray('[1, 2, 3]') // => [1, 2, 3]\n * stringToArray('foo') // => null\n * stringToArray('1') // => null\n * stringToArray('{\"foo\": \"bar\"}') // => null\n */\nexport function stringToArray(str) {\n  if (!/^\\s*\\[.*\\]\\s*$/.test(str)) return\n  try {\n    return JSON.parse(str)\n  } catch (e) {}\n}\n\n/**\n * Try to convert a string to an object\n * \n * @param {string} str The string to convert\n * @returns object The converted object or undefined if conversion failed\n * @example\n * stringToObject('{ \"foo\": \"bar\" }') // => { foo: 'bar' }\n * stringToObject('foo') // => null\n * stringToObject('1') // => null\n * stringToObject('[1, 2, 3]') // => null\n */\nexport function stringToObject(str) {\n  if (!/^\\s*\\{.*\\}\\s*$/.test(str)) return\n  try {\n    return JSON.parse(str)\n  } catch (e) {}\n}\n\n/**\n * Try to convert a string to a regex\n * \n * @param {string} str The string to convert\n * @returns regex The converted regex or undefined if conversion failed\n * @example\n * stringToRegex('/foo/i') // => /foo/i\n * stringToRegex('foo') // => null\n * stringToRegex('1') // => null\n */\nexport function stringToRegex(str) {\n  if (!/^\\s*\\/.*\\/g?i?\\s*$/.test(str)) return\n  try {\n    return new RegExp(str)\n  } catch (e) {}\n}\n\n/**\n * Try to convert a string to a primitive\n * \n * @param {string} str The string to convert\n * @returns {null|boolean|int|float|string} The converted primitive or input string if conversion failed\n * @example\n * stringToPrimitive('null') // => null\n * stringToPrimitive('true') // => true\n * stringToPrimitive('false') // => false\n * stringToPrimitive('1') // => 1\n * stringToPrimitive('1.5') // => 1.5\n * stringToPrimitive('foo') // => 'foo'\n * stringToPrimitive('1foo') // => '1foo'\n */\nexport function stringToPrimitive(str) {\n  if (/^\\s*null\\s*$/.test(str)) return null\n  const bool = stringToBoolean(str)\n  if (bool !== undefined) return bool\n  return stringToNumber(str) || str\n}\n\n/**\n * Try to convert a string to a data type\n * \n * @param {string} str The string to convert\n * @returns any The converted data type or input string if conversion failed\n * @example\n * stringToData('null') // => null\n * stringToData('true') // => true\n * stringToData('false') // => false\n * stringToData('1') // => 1\n * stringToData('1.5') // => 1.5\n * stringToData('foo') // => 'foo'\n * stringToData('1foo') // => '1foo'\n * stringToData('[1, 2, 3]') // => [1, 2, 3]\n * stringToData('{ \"foo\": \"bar\" }') // => { foo: 'bar' }\n * stringToData('/foo/i') // => /foo/i\n */\nexport function stringToType(str) {\n  if (/^\\s*null\\s*$/.test(str)) return null\n  const bool = stringToBoolean(str)\n  if (bool !== undefined) return bool\n  return stringToNumber(str) || stringToArray(str) || stringToObject(str) || stringToRegex(str) || str\n}\n\n/**\n * If provided variable is an object\n * \n * @param {any} o \n * @returns boolean\n * @example\n * isObject({}) // => true\n * isObject([]) // => false\n * isObject(null) // => false\n */\nexport function isObject(o) {\n  return typeof o === 'object' && !Array.isArray(o) && o !== null\n}\n\n/**\n * If provided variable is an array. Just a wrapper for Array.isArray\n * \n * @param {any} o\n * @returns boolean\n * @example\n * isArray([]) // => true\n * isArray({}) // => false\n */\nexport function isArray(o) {\n  return Array.isArray(o)\n}\n\n/**\n * If provided variable is a string. Just a wrapper for typeof === 'string'\n * \n * @param {any} o\n * @returns boolean\n * @example\n * isString('foo') // => true\n * isString({}) // => false\n */\nexport function isString(o) {\n  return typeof o === 'string'\n}\n\n/**\n * If provided variable is a function, substitute for typeof === 'function'\n * \n * @param {any} o\n * @returns boolean\n * @example\n * isFunction(function() {}) // => true\n * isFunction({}) // => false\n */\nexport function isFunction(o) {\n  return typeof o === 'function'\n}\n\n/**\n * If object property is a function\n * \n * @param {object} obj\n * @param {string} propertyName\n * @returns boolean\n * @example\n * const obj = { foo: 'bar', baz: function() {} }\n * propertyIsFunction(obj, 'foo') // => false\n * propertyIsFunction(obj, 'baz') // => true\n */\nexport function propertyIsFunction(obj, propertyName) {\n  return obj.hasOwnProperty(propertyName) && isFunction(obj[propertyName])\n}\n\n/**\n * If object property is a string\n * \n * @param {object} obj\n * @param {string} propertyName\n * @returns boolean\n * @example\n * const obj = { foo: 'bar', baz: function() {} }\n * propertyIsString(obj, 'foo') // => true\n * propertyIsString(obj, 'baz') // => false\n */\nexport function propertyIsString(obj, propertyName) {\n  return obj.hasOwnProperty(propertyName) && isString(obj[propertyName])\n}\n\n/**\n * Transforms a dash separated string to camelCase\n *\n * @param {string} str\n * @returns boolean\n * @example\n * transformDashToCamelCase('foo-bar') // => 'fooBar'\n * transformDashToCamelCase('foo-bar-baz') // => 'fooBarBaz'\n * transformDashToCamelCase('foo') // => 'foo'\n * transformDashToCamelCase('fooBarBaz-qux') // => 'fooBarBazQux'\n */\nexport function transformDashToCamelCase(str) {\n  return str.replace(/-([a-z])/g, function (g) { return g[1].toUpperCase() });\n}\n\n/**\n * Transforms a camelCase string to dash separated string\n * \n * @param {string} str\n * @returns boolean\n * @example\n * transformCamelCaseToDash('fooBar') // => 'foo-bar'\n * transformCamelCaseToDash('fooBarBaz') // => 'foo-bar-baz'\n * transformCamelCaseToDash('foo') // => 'foo'\n * transformDashToCamelCase('fooBarBaz-qux') // => 'foo-bar-baz-qux'\n */\nexport function transformCamelCaseToDash(str) {\n  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()\n}\n\n/**\n * Maps an array of objects by a property name\n * \n * @param {array} arr\n * @param {string} propertyName\n * @returns object\n * @example\n * const arr = [{ foo: 'bar' }, { foo: 'baz' }]\n * mapByProperty(arr, 'foo') // => { bar: { foo: 'bar' }, baz: { foo: 'baz' } }\n */\nexport function mapByProperty(arr, propertyName) {\n  const res = {}\n  for (let i = 0; i < arr.length; i++) {\n    res[arr[i][propertyName]] = arr[i]\n  }\n  return res\n}\n\n/**\n * Maps an array of objects by a property name to another property name\n * \n * @param {array} arr\n * @param {string} keyPropertyName\n * @param {string} valuePropertyName\n * @returns object\n * @example\n * const arr = [{ foo: 'bar', baz: 'qux' }, { foo: 'quux', baz: 'corge' }]\n * mapPropertyToProperty(arr, 'foo', 'baz') // => { bar: 'qux', quux: 'corge' }\n */\nexport function mapPropertyToProperty(arr, keyPropertyName, valuePropertyName) {\n  const res = {}\n  for (let i = 0; i < arr.length; i++) {\n    res[arr[i][keyPropertyName]] = arr[i][valuePropertyName]\n  }\n  return res\n}\n\n/**\n * Remove accents from a string\n * \n * @param {string} inputString\n * @returns string\n * @example\n * removeAccents('\u00E1\u00E9\u00ED\u00F3\u00FA') // => 'aeiou'\n * removeAccents('\u00C1\u00C9\u00CD\u00D3\u00DA') // => 'AEIOU'\n * removeAccents('se\u00F1or') // => 'senor'\n * removeAccents('\u0152') // => 'OE'\n */\nexport function removeAccents(inputString) {\n  return inputString.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').replace(/\\\u0153/g, \"oe\").replace(/\\\u00E6/g, \"ae\").normalize('NFC')\n}\n\n/**\n * Strip HTML tags from a string\n * \n * @param {string} inputString\n * @returns string\n * @example\n * stripHTMLTags('<span>foo</span>') // => 'foo'\n * stripHTMLTags('<span>foo</span> <span>bar</span>') // => 'foo bar'\n */\nexport function stripHTMLTags(inputString) {\n  return inputString.replace(/<[^>]*>/g, '')\n}\n\n/**\n * Slugify a string, e.g. 'Foo Bar' => 'foo-bar'. Similar to WordPress' sanitize_title(). Will remove accents and HTML tags.\n * \n * @param {string} str \n * @returns string\n * @example\n * slugify('Foo Bar') // => 'foo-bar'\n * slugify('Foo Bar <span>baz</span>') // => 'foo-bar-baz'\n */\nexport function slugify(str) {\n  str = str.trim().toLowerCase()\n  str = removeAccents(str)\n  str = stripHTMLTags(str)\n  return str.replace(/\\s+|\\.+|\\/+|\\\\+|\u2014+|\u2013+/g, '-').replace(/[^\\w0-9\\-]+/g, '').replace(/-{2,}/g, '-').replace(/^-|-$/g, '')\n}\n\n/**\n * Check if object has multiple properties\n * \n * @param {object} obj\n * @param {string|array} properties\n * @returns boolean\n * @example\n * const obj = { foo: 'bar', baz: 'qux' }\n * hasOwnProperties(obj, ['foo', 'baz']) // => true\n * hasOwnProperties(obj, ['foo', 'baz', 'qux']) // => false\n */\nexport function hasOwnProperties(obj, properties) {\n  if(!isArray(properties)) properties = [properties]\n  for (let i = 0; i < properties.length; i++) {\n    if (!obj.hasOwnProperty(properties[i])) return false\n  }\n  return true\n}\n\n/**\n * Finds the closest number to the set goal in an array to a given number\n * \n * @param {number} goal Number to search for\n * @param {array} arr Array of numbers to search in\n * @returns number\n * @example\n * closestNumber(10, [1, 2, 3, 4, 5, 6, 7, 8, 9]) // => 9\n * closestNumber(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 11]) // => 9\n * closestNumber(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 9.5]) // => 9.5\n * closestNumber(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11) // => 10\n */\nexport function closestNumber(goal, arr) {\n  return arr.reduce(function(prev, curr) {\n    return Math.abs(curr - goal) < Math.abs(prev - goal) ? curr : prev\n  })\n}\n\n/**\n * Truncate a string to a given number of words\n * \n * @param {string} str String to truncate\n * @param {number} numWords Number of words to truncate to\n * @param {string} ellipsis Ellipsis to append to the end of the string\n * @returns string\n * @example\n * truncateString('foo bar baz', 2) // => 'foo bar\u2026'\n * truncateString('foo bar baz', 2, '...') // => 'foo bar...'\n * truncateString('foo bar. baz', 2, '...') // => 'foo bar. ...'\n */\nexport function truncateString(str, numWords, ellipsis = '\u2026') {\n  const words = str.trim().split(' ')\n  if (words.length <= numWords) return str\n  if (numWords <= 0) return ''\n  if (/[.?!]$/.test(words[numWords - 1]) && ellipsis.trim() !== '') ellipsis = ` ${ellipsis}`\n  return words.slice(0, numWords).join(' ') + ellipsis\n}\n\n/**\n * Generates a random integer between two values, inclusive of both\n * \n * @param {number} min Minimum value\n * @param {number} max Maximum value\n * @param {boolean} safe Defaults to false, if true will use a cryptographically secure random number generator\n * @returns number\n * @example\n * randomIntInclusive(1, 10) // => 1\n * randomIntInclusive(1, 10) // => 10\n * randomIntInclusive(1, 10) // => 5\n */\nexport function randomIntInclusive(min, max, safe = false) {\n  min = Number(min)\n  max = Number(max)\n  if (isNaN(min) || isNaN(max)) throw new TypeError('Both min and max must be numbers')\n  if (min > max) [min, max] = [max, min]\n  if (min === max) return min\n  min = Math.round(min)\n  max = Math.round(max)\n  const rand = safe ? random() : Math.random()\n  return Math.floor(rand * (max - min + 1)) + min\n}\n\n/**\n * Gets fixed number of digits after the decimal point\n * \n * @param {number} number Number to fix\n * @param {number} digits Number of digits to fix to\n * @returns number\n * @example\n * fixed(1.234, 2) // => 1.23\n * fixed(1.235, 2) // => 1.24\n * fixed(1.234) // => 1\n * fixed(1.234, 0) // => 1\n * fixed(1.234, 5) // => 1.234\n * @note Gotta ask myself why I wrote this function in the first place... \uD83E\uDD14 It's just not useful in a lot of cases lol...\n */\nexport function fixed(number, digits) {\n  if (!digits) return parseInt(number)\n  return parseFloat(number.toFixed(digits))\n}\n\n/**\n * Calculates the percentage of a number in relation to another number\n * \n * @param {number} num Number to calculate percentage of\n * @param {number} total Total number\n * @returns number\n * @example\n * percentage(1, 10) // => 10\n * percentage(5, 10) // => 50\n * percentage(10, 10) // => 100\n * percentage(0, 10) // => 0\n * percentage(10, 2) // => 500\n */\nexport function percentage(num, total) {\n  if (!num || !total || Number.isNaN(num) || Number.isNaN(total)) return 0\n  return num / total * 100\n}\n\nexport function pickProperties(obj, props) {\n  const res = {}\n  if (!props) return res\n  if (!isArray(props)) props = [props]\n  for (let i = 0; i < props.length; i++) {\n    if (obj.hasOwnProperty(props[i])) res[props[i]] = obj[props[i]]\n  }\n  return res\n}\n\nexport function rejectProperties(obj, props, clone = true) {\n  if (clone) obj = { ...obj }\n  if (!props) return obj\n  if (!isArray(props)) props = [props]\n  for (let i = 0; i < props.length; i++) {\n    if (obj.hasOwnProperty(props[i])) delete obj[props[i]]\n  }\n  return obj\n}\n\nexport function pickArrayElements(arr, indexes) {\n  if (!isArray(arr)) return\n  if (!isArray(indexes)) indexes = [indexes]\n  const res = []\n  for (let i = 0; i < indexes.length; i++) {\n    if (arr.hasOwnProperty(indexes[i])) res.push(arr[indexes[i]])\n  }\n  return res\n}\n\nexport function rejectArrayElements(arr, indexes, clone = true) {\n  if (clone) arr = [...arr]\n  if (!isArray(arr)) return\n  if (!isArray(indexes)) indexes = [indexes]\n  for (let i = indexes.length - 1; i >= 0; i--) {\n    if (arr.hasOwnProperty(indexes[i])) arr.splice(indexes[i], 1)\n  }\n  return arr\n}\n\n/**\n * Pick properties from an object or elements from an array\n * \n * @param {array} obj Object or array to pick properties or elements from\n * @param {array | string | number} props Properties to remove, can be an array of strings or a single string or number\n * @returns object | array | undefined\n * @example\n * \n * pick({ foo: 'bar', bar: 'baz', baz: 'qux' }) // => {}\n * pick({}, []) // => {}\n * pick(null, 'foo') // => undefined\n * pick({ foo: 'bar', bar: 'baz', baz: 'qux' }, undefined) // => {}\n * pick({ foo: 'bar', bar: 'baz', baz: 'qux' }, 'foo') // => { foo: 'bar'}\n * pick({ foo: 'bar', bar: 'baz', baz: 'qux' }, ['foo', 'baz']) // => { foo: 'bar', baz: 'qux' }\n * \n * pick(['foo', 'bar', 'baz'], []) // => []\n * pick([], []) // => []\n * pick(null, 0) // => undefined\n * pick(['foo', 'bar', 'baz'], undefined) // => []\n * pick(['foo', 'bar', 'baz'], 0) // => ['foo']\n * pick(['foo', 'bar', 'baz'], [0, 2]) // => ['foo', 'baz']\n * pick(['foo', 'bar', 'baz'], [0, 2, 3]) // => ['foo', 'baz']\n */\nexport function pick(obj, props) {\n  return isObject(obj) ? pickProperties(obj, props) : pickArrayElements(obj, props)\n}\n\n/**\n * Remove properties from an object or elements from an array\n * \n * @param {array} obj Object or array to remove properties or elements from\n * @param {array | string | number} props Properties to remove, can be an array of strings or a single string or number\n * @param {boolean} clone Defaults to true, will clone the object or array before removing properties or elements.\n * @returns object | array | undefined\n * @example\n * \n * reject({ foo: 'bar', bar: 'baz', baz: 'qux' }) // => {}\n * reject({}, []) // => {}\n * reject(null, 'foo') // => undefined\n * reject({ foo: 'bar', bar: 'baz', baz: 'qux' }, undefined) // => {}\n * reject({ foo: 'bar', bar: 'baz', baz: 'qux' }, 'foo') // => { bar: 'baz', baz: 'qux' }\n * reject({ foo: 'bar', bar: 'baz', baz: 'qux' }, ['foo', 'baz']) // => { bar: 'baz' }\n * \n * reject(['foo', 'bar', 'baz'], []) // => []\n * reject([], []) // => []\n * reject(null, 0) // => undefined\n * reject(['foo', 'bar', 'baz'], undefined) // => []\n * reject(['foo', 'bar', 'baz'], 0) // => ['bar', 'baz']\n * reject(['foo', 'bar', 'baz'], [0, 2]) // => ['bar']\n * reject(['foo', 'bar', 'baz'], [0, 2, 3]) // => ['bar']\n */\nexport function reject(obj, props, clone = true) {\n  return isObject(obj) ? rejectProperties(obj, props, clone) : rejectArrayElements(obj, props, clone)\n}\n\n/**\n * Basic timestamp first UID generator that's good enough for most use cases but not for security purposes.\n * There's an extremely small chance of collision, so create a map object to check for collisions if you're worried about that.\n * \n * - `Date.now().toString(16)` is used for the timestamp, which is a base16 representation of the current timestamp in milliseconds.\n * - `random().toString(16).substring(2)` is used for the random number, which is a base16 representation of a random number between 0 and 1, with the first two characters removed.\n * \n * @param {boolean} safe Defaults to false, if true will use a cryptographically secure random number generator for the random number improving security but reducing performance. If crypto is not available, will use Math.random() instead.\n * @returns string\n * @example\n * basicUID() // => '18d4613e4d2-750bf066ac6158'\n */\nexport function basicUID(safe = false) {\n  const rand = safe ? random() : Math.random()\n  return Date.now().toString(16)+'-'+rand.toString(16).substring(2)\n}\n\nfunction cryptoUUIDFallback() {\n  return '10000000-1000-4000-8000-100000000000'.replace(/[018]/g, c =>\n   (c ^ Math.random() * 16 >> c / 4).toString(16)\n  )\n}\n\n// Taken from https://stackoverflow.com/a/2117523/5437943\nfunction cryptoRandomUUIDFallback() {\n  return '10000000-1000-4000-8000-100000000000'.replace(/[018]/g, c =>\n    (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)\n  )\n}\n\n/**\n * Generates a UUID v4\n * - Uses crypto.randomUUID if available\n * - Uses crypto.getRandomValues if available\n * - Uses a fallback if neither is available, which is not safe because it uses Math.random() instead of a cryptographically secure random number generator\n * \n * I'm bad at crypto and bitwise operations, not my cup of tea, so I had to rely on StackOverflow for the fallback: https://stackoverflow.com/a/2117523/5437943\n * \n * @param {boolean} safe Defaults to true, if false will use a fallback that's not cryptographically secure but significantly faster\n * @returns string\n * @example\n * generateUUID() // UUID v4, example 09ed0fe4-8eb6-4c2a-a8d3-a862b7513294\n */\nexport function generateUUID(safe = true) {\n  if (!crypto || !safe) return cryptoUUIDFallback()\n  if (crypto.randomUUID) return crypto.randomUUID()\n  if (crypto.getRandomValues) return cryptoRandomUUIDFallback();\n}\n\n/**\n * Generates a random number between 0 and 1, inclusive of 0 but not inclusive of 1.\n * \n * - Uses crypto.getRandomValues if available\n * - Uses Math.random() if crypto.getRandomValues is not available\n * \n * @returns number\n * @example\n * random() // => 0.123456789\n */\nexport function random() {\n  if (!crypto) return Math.random()\n  if (crypto.getRandomValues) return crypto.getRandomValues(new Uint32Array(1))[0] / 4294967295 // 2^32 - 1 = 4294967295\n}\n", "import { shallowMerge } from 'book-of-spells'\n\n/**\n * @name Slideswap\n * @description\n */\nexport default class Slideswap {\n  constructor(element, options) {\n    this.element = element\n    this.currentIndex = 0\n    this.slides = null\n    this.maxHeight = 0\n    this.options = {\n      infinite: false,\n      activeClass: 'slideswap-current-slide',\n      slideClass: 'js-slideswap',\n      start: 0,\n      adaptiveHeight: true,\n      next: null,\n      prev: null,\n      imageClass: 'js-slideswap-image',\n    }\n    if (typeof element === 'string') this.element = document.querySelector(element)\n\n    if (!this.element || !(this.element instanceof HTMLElement)) {\n      throw new Error('slideswap: element property not provided, or element not found')\n    }\n\n    if (this.element.getAttribute('data-slideswap-initialized') === 'true') {\n      throw new Error('slideswap: element already initialized')\n    }\n\n    shallowMerge(\n      this.options,\n      options\n    )\n\n    this.bindControls()\n\n    this.slides = this.element.querySelectorAll(`.${this.options.slideClass}`)\n    this.setCurrentSlide(this.options.start)\n    this.element.setAttribute('data-slideswap-initialized', 'true')\n\n    this.setupSlides()\n  }\n\n  bindControls() {\n    if (!this.options.next && !this.options.prev) return\n    this.options.next = typeof this.options.next === 'string' ? document.querySelector(this.options.next) : this.options.next\n    this.options.prev = typeof this.options.prev === 'string' ? document.querySelector(this.options.prev) : this.options.prev\n\n    if (this.options.next) this.options.next.addEventListener('click', this.next.bind(this))\n    if (this.options.prev) this.options.prev.addEventListener('click', this.previous.bind(this))\n  }\n\n  setupSlides() {\n    for (let i = 0; i < this.slides.length; i++) {\n      const slide = this.slides[i]\n      slide.setAttribute('data-slideswap-index', i)\n      this.maxHeight = Math.max(this.maxHeight, slide.offsetHeight)\n    }\n\n    if (!this.options.adaptiveHeight) {\n      this.element.style.height = `${this.maxHeight}px`\n    }\n  }\n\n  setCurrentSlide(index) {\n    if (index < 0 || index >= this.slides.length) return\n    this.currentIndex = index\n    const currentSlide = this.slides[index]\n    currentSlide.classList.add(this.options.activeClass)\n    currentSlide.removeAttribute('aria-hidden')\n    currentSlide.setAttribute('tabindex', '0')\n    currentSlide.style.zIndex = 1\n    currentSlide.style.opacity = 1\n    currentSlide.style.pointerEvents = 'auto'\n\n    if (this.options.adaptiveHeight) {\n      this.element.style.height = `${currentSlide.offsetHeight}px`\n\n      const image = this.getCurrentSlide().querySelector(`.${this.options.imageClass}`)\n      if (image) {\n        image.addEventListener('load', () => {\n          this.element.style.height = `${currentSlide.offsetHeight}px`\n        })\n      }\n    }\n\n    for (let i = 0; i < this.slides.length; i++) {\n      const slide = this.slides[i]\n      if (i === index) continue\n      slide.classList.remove(this.options.activeClass)\n      slide.setAttribute('aria-hidden', 'true')\n      slide.setAttribute('tabindex', '-1')\n      slide.style.zIndex = 0\n      slide.style.opacity = 0\n      slide.style.pointerEvents = 'none'\n    }\n  }\n\n  getCurrentIndex() {\n    return this.currentIndex\n  }\n\n  getCurrentSlide() {\n    return this.slides[this.currentIndex]\n  }\n\n  getNextIndex() {\n    return this.options.infinite ? (this.currentIndex + 1) % this.slides.length : this.currentIndex + 1\n  }\n\n  getPreviousIndex() {\n    return this.options.infinite ? (this.currentIndex - 1 + this.slides.length) % this.slides.length : this.currentIndex - 1\n  }\n\n  next() {\n    this.setCurrentSlide(this.getNextIndex())\n  }\n\n  previous() {\n    this.setCurrentSlide(this.getPreviousIndex())\n  }\n\n  destroy() {\n    this.element = null\n    this.slides = null\n    this.options = null\n    this.currentIndex = null\n    this.maxHeight = null\n\n    if (this.options.next) this.options.next.removeEventListener('click', this.next.bind(this))\n    if (this.options.prev) this.options.prev.removeEventListener('click', this.previous.bind(this))\n  }\n\n  addSlide(slide) {\n    this.element.appendChild(slide)\n    this.slides = this.element.querySelectorAll(`.${this.options.slideClass}`)\n    this.setupSlides()\n  }\n\n  removeSlide(index) {\n    this.element.removeChild(this.slides[index])\n    this.slides = this.element.querySelectorAll(`.${this.options.slideClass}`)\n    if (this.currentIndex >= this.slides.length) this.setCurrentSlide(this.slides.length - 1)\n    this.setupSlides()\n  }\n}\n", "import Slideswap from '../slideswap.js';\n\nif (!window.Slideswap) {\n  window.Slideswap = Slideswap;\n}\n"],
  "mappings": "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",
  "names": []
}
